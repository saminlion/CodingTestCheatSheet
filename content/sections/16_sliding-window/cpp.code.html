// 정수 배열 arr에서 길이 k인 연속 부분 배열 중에서 가장 큰 합을 구하는 알고리즘
// 슬라이딩 윈도우 기법을 사용하여 O(N) 시간 복잡도로 처리

int sum = 0;

// 1. 처음 윈도우(0 ~ k-1)의 합을 미리 계산한다.
//    → 슬라이딩 윈도우의 시작점으로, 이후 한 칸씩 밀어가며 갱신할 예정
for (int i = 0; i < k; i++) {
    sum += arr[i];
}

// 2. maxSum을 현재 윈도우 합으로 초기화
int maxSum = sum;

// 3. 윈도우를 한 칸씩 오른쪽으로 이동하면서 최대값을 갱신
//    i는 새로 추가될 요소의 인덱스를 의미한다 (윈도우 오른쪽 끝)
for (int i = k; i < arr.size(); i++) {
    // 오른쪽에 새로 들어온 값을 더함
    sum += arr[i];

    // 왼쪽에서 빠져나간 값을 뺌 (i - k가 윈도우 왼쪽 끝 인덱스)
    sum -= arr[i - k];

    // 현재 윈도우 합과 기존 최대값을 비교하여 더 큰 값으로 갱신
    maxSum = max(maxSum, sum);
}

// 최종적으로 maxSum에는 가장 큰 k구간 합이 저장된다
